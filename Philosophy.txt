Because of the scope of this project, and the expectation that it will require continued updates and maintenance, I'm going to indulge in a short discussion of why this piece of software is arranged the way it is.

The design was most heavily influenced by my reflections on 6.858, the Computer Systems Security course I took in the fall of 2013. It's an excellent course to take, I highly recommend it. Two key points from this class:

* Make security principals simple and explicit -- poorly configured systems are indistinguishable from buggy systems.
* Expect failures, especially orchestrated catastrophic failures. Make sure that different parts of the application are separated in case of failure, and all degrade gracefully.

In the API's original conception (due to discussions over IAP 2014), we were shaped by our wish to prevent a repeat of the situation Simmons Tech finds ourselves facing as I write this; namely, the current database is monolithic. Therefore, it is nearly impossible to replace any part of it without greatly modifying the whole. Our past forays into modifying the database have therefore been somewhat limited, and over time, knowledge of how to work with this system has been largely lost.

To prevent this, we want our new system to be split into sensibly sized chunks. There should be no part that cannot be understood in a day and rewritten in a weekend. We also want to base our services on the most lasting, flexible interfaces possible, and we want to enable quick deployment of any application by any resident over all the data we can offer (without compromising resident privacy or security of course).

To this end, the Simmons API is designed as a series of independent applications (I will refer to these as silos), each of which has responsibility for a particular aspect of the dorm. A point of note (and contention in our design): we have chosen to give up the idea of an atomic operation over multiple silos. When designing a silo, keep this in mind. If it is essential that an atomic operation occur, then make sure everything involved ends up in the same silo. Do try to avoid bloated silos, however.

Each of these silos presents an HTTP API entirely of its design. Good API design is an art to itself, and I will leave it to the reader to spend the necessary time to make a good API. On top of all the silos is a dispatcher, which allows multiple APIs to run at the same address. This code is really simple forwarding, check it out.

For the time being, everything is written in Flask, a lightweight Python web framework, but we explicitly do not want to restrict future development to either Python or Flask, the concept of a silo is intended to be language agnostic. At the time of writing, the dispatcher does require Flask, the hope is to fix that very soon after the MVP launch.

We recognize that residents probably do not always want to manually interact with the API over HTTP. To this end, we provide thin JS and Python wrappers. These are autogenerated/compiled from a human readable YAML description of the API. The plan at the time of writing is to expand this to support C, C++, Java, etc. post MVP launch.

I hope this has served to motivate and describe our design at a high level. If I have one piece of advice for future developers of this system: prioritize modularity, readability, and readability over efficiency. Expect that the technologies that are your bread and butter today will be unheard of in 10 years. No matter what your bus factor, the metaphorical bus of time will hit you and everyone working on any particular tech project in no more than 4 years. Then it'll be up to someone else to make what you've done work for their needs. Try to put yourself in that person's shoes as you develop. Comment your code, make supporting documentation. Keep good git history.

Anyhow, that's a bit more than a single piece of advice. I'll leave it there and get back to the code.

~Will Oursler, 2015
woursler@mit.edu
